# DevOps-ITMO

# Лабораторная работа №3

Работы выполнили: Команда "Буцефалы"

## Введение

В данной лабораторной работе мы рассмотрим настройку CI/CD пайплайна с использованием GitHub Actions. 
Рассмотрим плохие практики, а затем скоренько исправим их, чтобы не отложились.

## Bad practices

```
name: CI/CD Pipeline

on:
  push:
    branches:
      - '*'
  pull_request:
    branches:
      - '*'

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Install dependencies without version control
        run: npm install --legacy-peer-deps

      - name: Run tests without fail
        run: |
          npm test || echo "Tests failed, skipping..."

      - name: Build project
        run: |
          npm run build || echo "Build failed, skipping..."

  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Deploy directly to production without conditions
        run: echo "Deploying without approval..."
```

Определим ряд ~~не~~ очевидных проблем.

1. Запускаются пайпы для всех веток, что создает лишнюю нагрузку и может привести к выполнению ненужных действий. 
2. Используется устаревшая версия экшенов, а это повышенный риск уязвимостей и отсутствия новых улучшений. 
3. Установка зависимостей выполняется с флагом игнорирования конфликтов версий, что зачастую приводит к нестабильной работе. 
4. Ошибки тестов игнорируются, что делает тестирование бессмысленным, так как ошибки не крашат пайпу. 
5. Ошибки сборки также игнорируются, что позволяет развернуть некорректный код. 
6. Развертывание происходит без проверки условий и контроля веток, что может привести к развертыванию на прод случайного кода. 
7. Отсутствие строгого контроля за выполнением этапов делает пайплайн ненадежным и потенциально опасным. 
8. Пропуск ошибок в любом этапе увеличивает риск поломок и необходимости исправлений уже после развертывания.

## Good practices

Что ж, а теперь самое время исправить наши косяки:

```
name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js (example for Node.js project)
        uses: actions/setup-node@v3
        with:
          node-version: '16'

      - name: Install dependencies
        run: npm install

      - name: Run tests
        run: npm test

      - name: Build project
        run: npm run build

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Deploy to production
        run: echo "Deployment step would be added here."
```

На что же теперь стоит обратить внимание:
1. Хороший файл использует точные триггеры, например, только для ветки main, исключая ненужные запуски. 
2. Применяются актуальные версии экшенов. 
3. Установка зависимостей выполняется корректно, избегая игнорирования конфликтов версий. 
4. Тесты обязательны для выполнения, и их провал завершает процесс сборки, предотвращая пропуск ошибок.
5. Ошибки сборки не игнорируются, а значит мы не пропустим свои косяки. 
6. Развертывание выполняется только после успешной сборки и тестирования, контролируется веткой main или другими условиями. 
7. В хорошем файле обеспечивается предсказуемость всех этапов. 
8. Любая ошибка в процессе блокирует последующие шаги, защищая производственную среду.

## Вывод
В итоге, как наши изменения повлияли на работу:
Теперь процесс CI/CD стал более безопасным, быстрым и контролируемым. Каждый из этих пунктов очень важен для успешного развертования приложений в prod. Все как завещал дядюшка Боб.

## P.S. История о том, как я создавал сервер на React ради пайплайна
Итак, с чего всё началось? Представьте: ты заходишь в папку проекта, полный оптимизма, с редбульчика, с командой "npm start" в буфере, а терминал выдает: "index.html не найден". Ты думаешь: "Ну, ладно, ща поправим". Создаешь `index.html`. 

Следующий запуск: "index.js не найден". И тут понеслась: добавляешь `index.js`, потом `App.js`, потом `index.css`. В какой-то начинаешь задумываться, а кто вообще пишет код для React-приложений? Потому что я, кажется, только и делаю, что закрываю ошибки. 

Код заработал, но выглядел так, как будто его неделю нещадно ~~били~~, обижали в общем. Ну и ладно, главное, чтобы сборка прошла. Пайплайн зеленый! Но тут следующая гениальная мысль посещает тебя: "А что, если сервер-то в итоге развернуть?" 

Создал сервер на локалке, который просто принтит в консоль. По сути, это был React-бот, который служил одной цели — чтобы пайплайн наконец-то стал зеленым.

Представили? А мне и представлять не надо. 

Команда Буцефалы

![Логооооо](bucefalu.jpeg)
